// ROBOTBUILDER TYPE: Command.

package frc.robot.commands;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.RobotContainer;
import frc.robot.subsystems.DriveSubsystem;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.Drivetrain;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class TankDrive extends CommandBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
        private final DriveSubsystem m_drivetrain;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    private Joystick m_joystick = new Joystick(0);
    //RobotContainer.getInstance().getJoystick1();   //issue
    // private Joystick rightJoystick = new Joystick(0);
    //    RobotContainer.getInstance().getJoystick2();  //issue

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS


    public TankDrive(DriveSubsystem subsystem) {


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

        m_drivetrain = subsystem;
        addRequirements(m_drivetrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        double accelFactor = 2.0;
        double slowFactor = 0.85;
        //The % power used
        final double turnLimit = 0.4;
        double speedLimit=0.7;
        final double lTankAdj= 0.1;
        double right = m_joystick.getRawAxis(1);
        double left = m_joystick.getRawAxis(3);
        double lprime = -Math.pow(right,3);
        double rprime = Math.pow(left,3);
        final double deadZone=0.4;
        final double minZone=0.07;
        if(minZone<Math.abs(lprime)){
            // lprime=deadZone*Math.signum(lprime);
              lprime=(Math.abs(lprime)/lprime)*(deadZone+speedLimit*(1-deadZone)*(Math.abs(lprime))/(0.9));
              
              // DriverStation.reportWarning("BANANA"+((Double)Math.abs(lprime)).toString(),true);
          }
          else{
            lprime=0;
          }
          if(minZone<Math.abs(rprime)){
            rprime=(Math.abs(rprime)/rprime)*(deadZone+speedLimit*(1-deadZone)*(Math.abs(rprime))/(0.9));
            // if (lprime<0){
            //   lprime*=leftAdj;
            // }
              //DriverStation.reportWarning("KIWI"+((Double)Math.abs(rprime)).toString(),true);
          }
          else{
            rprime=0;
          }
          
            if(m_joystick.getRawButton(5)){
                lprime*=accelFactor;
                rprime*=accelFactor; 
            }
            
            if(m_joystick.getRawButton(6)){
                rprime*=slowFactor; 
                lprime*=slowFactor; 
            }
            lprime += lTankAdj;
        m_drivetrain.drive(rprime, lprime);  //issue
    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
        m_drivetrain.drive(0.0, 0.0);
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}